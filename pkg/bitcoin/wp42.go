package bitcoin

import (
	"crypto/rand"
	"math/big"
	"time"

	"github.com/pkg/errors"
)

// WP42 is a method of deriving a hierarchy of keys.
// A chain of keys can be derived from a base key (public or private) and a seed value. The first
//   key in the chain is just the base key with the hash of the seed value added to it. Each
//   consecutive key is generated by re-hashing the hash used to generate the previous key and
//   adding it to the base key again.
//
// To branch from a chain, for a hierarchy, start with the first hash of the seed value again, or
//   use a new value, and use a key from the chain as the new base key, creating a new chain from
//   that key.
//
//   // Generate a base key and seed value
//   baseKey, err := GenerateKey(MainNet)
//   seedValue, err := GenerateSeedValue()
//
//   // Derive keys in chain
//   chainKey1, err := NextKey(baseKey, NextHash(seedValue))
//   chainKey2, err := NextKey(baseKey, NextHash(NextHash(seedValue)))
//   ...
//
//   // Branch from the second key in the main chain
//   branchKey2_1, err := NextKey(chainKey2, NextHash(seedValue))
//   branchKey2_2, err := NextKey(chainKey2, NextHash(NextHash(seedValue)))

// GenerateSeedValue generates a random seed value that can be used to derive keys.
func GenerateSeedValue() (Hash32, error) {
	b := make([]byte, 32)

	if _, err := rand.Read(b); err != nil {
		return Hash32{}, errors.Wrap(err, "random")
	}

	var val big.Int
	val.SetBytes(b)

	// For added randomness
	now := time.Now()
	addVal := big.NewInt(now.UnixNano())

	val.Add(&val, addVal)

	// Extend to 32 bytes
	b = val.Bytes()
	if len(b) < 32 {
		extra := make([]byte, 32-len(b))
		b = append(extra, b...)
	}

	result, err := NewHash32(b)
	if err != nil {
		return Hash32{}, errors.Wrap(err, "new hash")
	}
	return *result, nil
}

// NextHash returns the SHA256 hash of the hash used to generate the next key in a chain.
func NextHash(hash Hash32) Hash32 {
	b := Sha256(hash.Bytes())
	result, _ := NewHash32(b) // The error can be ignored because it can only fail from size
	return *result
}

// NextKey implements the WP42 method of deriving a private key from a private key and a hash.
func NextKey(baseKey Key, hash Hash32) (Key, error) {
	// Add hash to key value
	b := addPrivateKeys(baseKey.value.Bytes(), hash.Bytes())

	return KeyFromNumber(b, baseKey.Network())
}

// NextPublicKey implements the WP42 method of deriving a public key from a public key and a hash.
func NextPublicKey(baseKey PublicKey, hash Hash32) (PublicKey, error) {
	var result PublicKey

	// Multiply hash by G
	x, y := curveS256.ScalarBaseMult(hash.Bytes())

	// Add to public key
	x, y = curveS256.Add(&baseKey.X, &baseKey.Y, x, y)

	// Check validity
	if x.Sign() == 0 || y.Sign() == 0 {
		return result, ErrOutOfRangeKey
	}

	result.X.Set(x)
	result.Y.Set(y)

	return result, nil
}

// IndexedHash returns the SHA256 hash of the hash used to generate the next key in a chain.
func IndexedHash(hash Hash32, index uint64) Hash32 {
	for i := uint64(0); i < index; i++ {
		hash.Sha256()
	}
	return hash
}

// ChildKey derives a child key at a specified index.
func ChildKey(key Key, seedValue Hash32, index uint64) (Key, error) {
	return NextKey(key, IndexedHash(seedValue, index))
}

// ChildKey derives a child key at a specified index.
func ChildPublicKey(key PublicKey, seedValue Hash32, index uint64) (PublicKey, error) {
	return NextPublicKey(key, IndexedHash(seedValue, index))
}
